<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MicroHealth Project Report</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #34495e;
            --accent-color: #3498db;
            --bg-color: #ffffff;
            --text-color: #333333;
            --code-bg: #f4f6f7;
            --border-color: #eaeaea;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            max-width: 900px;
            margin: 0 auto;
            padding: 40px;
            background: var(--bg-color);
        }

        /* Print Styling */
        @media print {
            body { font-size: 12pt; padding: 0; }
            a { text-decoration: none; color: black; }
            .no-print { display: none; }
            h1, h2, h3 { page-break-after: avoid; }
            pre, blockquote { page-break-inside: avoid; }
            .page-break { page-break-before: always; }
        }

        /* Typography */
        h1 {
            font-size: 2.5em;
            color: var(--primary-color);
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 10px;
            margin-top: 0;
        }
        h2 {
            font-size: 1.8em;
            color: var(--secondary-color);
            margin-top: 40px;
            border-bottom: 1px solid var(--border-color);
        }
        h3 {
            font-size: 1.4em;
            color: var(--secondary-color);
            margin-top: 30px;
        }
        p { margin-bottom: 15px; }

        /* Components */
        .title-page {
            text-align: center;
            padding: 100px 0;
            margin-bottom: 100px;
        }
        .title-page h1 { border: none; font-size: 4em; color: var(--accent-color); }
        .subtitle { font-size: 1.5em; color: #7f8c8d; }
        .meta { margin-top: 50px; font-size: 1.1em; color: #95a5a6; }

        code {
            background: var(--code-bg);
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            color: #e74c3c;
        }

        pre {
            background: var(--primary-color);
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.9em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            padding: 12px;
            border: 1px solid var(--border-color);
            text-align: left;
        }
        th { background: var(--code-bg); color: var(--primary-color); }

        .callout {
            background: #e8f6f3;
            border-left: 5px solid #1abc9c;
            padding: 15px;
            margin: 20px 0;
        }
        .alert {
            background: #fdedec;
            border-left: 5px solid #e74c3c;
            padding: 15px;
            margin: 20px 0;
        }

        .mermaid { margin: 30px 0; text-align: center; }
    </style>
</head>
<body>
    <script>mermaid.initialize({startOnLoad:true});</script>

    <div class="title-page">
        <h1>MicroHealth</h1>
        <div class="subtitle">Microservice Health Monitoring System</div>
        <div class="meta">
            Developed by Pranay<br>
            Project Documentation & Technical Report<br>
            January 2026
        </div>
    </div>

    <div class="page-break"></div>

    <h2>1. Executive Summary</h2>
    <p>
        <strong>MicroHealth</strong> is a robust architectural prototype demonstrating the <strong>"Heartbeat" pattern</strong> in distributed systems. 
        It solves the critical problem of <em>Service Discovery and Health Monitoring</em> in a microservices environment.
    </p>
    <p>
        In a real-world scenario with hundreds of services (Payment, Auth, Checkout, etc.), it is impossible to manually check if they are running. 
        MicroHealth implements a centralized <strong>Health Check Server</strong> that listens for "heartbeats" (regular HTTP signals) from satellite services. 
        If a service stops sending heartbeats (due to crash or network failure), the system automatically flags it as <strong>DOWN</strong>.
    </p>

    <h2>2. System Architecture</h2>
    
    <h3>High-Level Data Flow</h3>
    <div class="mermaid">
    graph TD
        subgraph "Microservices Layer"
            CS[Checkout Service] -- "GET /checkoutBeat (Every 35s)" --> S[Central Server]
            PS[Payment Service] -- "GET /paymentBeat (Every 30s)" --> S
        end
        
        subgraph "Core System"
            S[Node.js Express Server] -- "Writes Timestamp" --> DB[(data.json)]
            DB -- "Reads Timestamp" --> S
        end
        
        subgraph "Presentation Layer"
            FE[Frontend Dashboard] -- "Polling (Every 10s)" --> S
            S -- "JSON Response" --> FE
        end
        
        style CS fill:#f9f,stroke:#333
        style PS fill:#f9f,stroke:#333
        style S fill:#bbf,stroke:#333
        style DB fill:#bfb,stroke:#333
        style FE fill:#ff9,stroke:#333
    </div>

    <h3>Technical Stack Logic</h3>
    <ul>
        <li><strong>Node.js & Express</strong>: Chosen for non-blocking I/O, perfect for handling high-frequency heartbeat requests without lag.</li>
        <li><strong>JSON Filesystem DB</strong>: Used here for simplicity and zero-configuration persistence. In production, this would be Redis or a Time-Series Database.</li>
        <li><strong>Axios</strong>: Robust HTTP client used over `fetch` for its automatic JSON parsing and better error handling.</li>
        <li><strong>Vanilla JS Frontend</strong>: Lightweight dashboard without the overhead of React/Angular, ensuring instant loading.</li>
    </ul>

    <div class="page-break"></div>

    <h2>3. Component Deep Dive</h2>

    <h3>A. The Central Server (<code>index.js</code>)</h3>
    <p>The "Brain" of the system. It exposes two types of endpoints:</p>
    <ol>
        <li><strong>Writer Endpoint</strong> (<code>/:serviceName</code>): Captures the heartbeat.</li>
        <li><strong>Reader Endpoint</strong> (<code>/get/:serviceName</code>): Serves the status.</li>
    </ol>

    <div class="callout">
        <strong>Key Code Pattern:</strong> Dynamic Routing using <code>req.params</code> allows us to add infinite new services (Delivery, Auth, Email) without changing the server code.
    </div>

<pre><code>// Dynamic Route Handler
app.get("/:serviceName",(req,res)=>{
    // 1. Capture the service name from URL
    let {serviceName} = req.params;

    // 2. Update In-Memory Object
    data[serviceName] = Date.now();

    // 3. Persist to Disk (Critical for Crash Recovery)
    fs.writeFileSync("./data.json", JSON.stringify(data,null,2));

    res.send("YES");
});</code></pre>

    <h3>B. The Satellite Services (<code>MICROSERVICES/</code>)</h3>
    <p>These represent the actual business logic containers. They run autonomously.</p>
    <p><strong>The "Heartbeating" Mechanism:</strong></p>
    <p>
        They use <code>setInterval</code> to create an infinite loop. This is similar to a <em>Daemon Process</em>.
        Notice <code>checkout.js</code> sends every 35s and <code>payment.js</code> every 30s. This variation tests the server's ability to handle asynchronous updates.
    </p>

    <h3>C. The Dashboard (<code>public/app.js</code>)</h3>
    <p>The "Eyes" of the user. It uses the <strong>Polling Technique</strong>.</p>
    
    <div class="mermaid">
    sequenceDiagram
        participant User
        participant Browser
        participant Server
        
        User->>Browser: Opens Dashboard
        loop Every 10 Seconds
            Browser->>Server: GET /get/paymentBeat
            Server-->>Browser: Returns 170489203000
            Browser->>Browser: Calculate: (Now - Timestamp)
            alt Diff < 60s
                Browser->>Browser: Set Color GREEN
            else Diff > 60s
                Browser->>Browser: Set Color RED
            end
        end
    </div>

    <div class="page-break"></div>

    <h2>4. Advanced Technical Interview Questions</h2>

    <p>Be prepared to answer these deep-dive questions using this project as a reference.</p>

    <h4>Q1: Why use <code>fs.writeFileSync</code> instead of <code>writeFile</code>?</h4>
    <p>
        <strong>Answer:</strong> In this specific prototype, we use <code>Sync</code> to ensure data consistency. We don't want to read the file before the previous write is finished (Race Condition). 
        However, in a high-scale production app, blocking the Event Loop with Sync operations is bad practice. We would replace this with a Database (MongoDB/Redis) or use proper async/await with file locking.
    </p>

    <h4>Q2: What is "Polling" vs "WebSockets"? Why did you choose Polling?</h4>
    <p>
        <strong>Answer:</strong> 
        <ul>
            <li><strong>Polling (Used here)</strong>: The client asks the server "Any news?" every X seconds. Easiest to implement. Good for "Status" checks where millisecond latency doesn't matter.</li>
            <li><strong>WebSockets</strong>: The server pushes data to the client instantly. Better for Chat apps or Stock tickers.</li>
        </ul>
        I chose Polling because keeping a persistent WebSocket connection for a health dashboard is unnecessary overhead. Updates every 10 seconds are acceptable.
    </p>

    <h4>Q3: How would you scale this?</h4>
    <p>
        <strong>Answer:</strong>
        1. <strong>Database</strong>: Move from `data.json` to Redis (In-memory store) for extremely fast reads/writes.<br>
        2. <strong>Load Balancer</strong>: If we had 10,000 services, one Node server implies a bottleneck. We'd put Nginx in front of multiple Node instances.<br>
        3. <strong>Alerting</strong>: Instead of just turning Red, the system should integrate Twilio or PagerDuty APIs to SMS the DevOps team when a service dies.
    </p>

    <h2>5. Setup & Usage Guide</h2>
    
    <ol>
        <li><strong>Prerequisites</strong>: Install Node.js.</li>
        <li><strong>Installation</strong>: Run <code>npm install</code> to get Express and Axios.</li>
        <li><strong>Start Server</strong>: 
            <pre>node index.js</pre>
            Server runs on <code>http://localhost:3000</code>.
        </li>
        <li><strong>Start Services</strong>:
            Open new terminals for each:
            <pre>node MICROSERVICES/payment.js
node MICROSERVICES/checkout.js</pre>
        </li>
        <li><strong>Monitor</strong>: Open <code>http://localhost:3000</code> in your browser.</li>
    </ol>

    <div class="no-print" style="text-align: center; margin-top: 50px;">
        <button onclick="window.print()" style="padding: 10px 20px; font-size: 1.2em; cursor: pointer; background: #2c3e50; color: white; border: none; border-radius: 5px;">Save as PDF</button>
    </div>

</body>
</html>
